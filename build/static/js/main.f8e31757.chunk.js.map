{"version":3,"sources":["styles/index.js","utils/procedureTypes.js","app/VisualiserCore.js","algorithms/QuickSortRightPivot.js","algorithms/QuickSortMidPivot.js","algorithms/BubbleSort.js","algorithms/MergeSort.js","algorithms/HeapSort.js","algorithms/SelectionSort.js","algorithms/InsertionSort.js","app/Visualiser.jsx","utils/generators.js","index.js"],"names":["Colors","PROCEDURE_TYPE","swapBars","a","b","arrayBars","document","getElementsByClassName","temp","style","height","markComplete","i","length","backgroundColor","ProceduresReader","procedures","executionSpeed","between","ExecuteProcedure","procedure","Promise","resolve","type","setTimeout","getQuickSortRightPivotProcedures","array","auxArray","slice","performQuickSortWithRightPivot","start","end","pIndex","pivot","push","swap","partitionWithRightPivot","arr","firstIndex","secondIndex","getQuickSortMidPivotProcedures","performQuickSortWithMidPivot","mid","Math","floor","left","right","getBubbleSortProcedures","lengh","runLoop","getMergeSortProcedures","performMergeSort","merge","getHeapSortProcedures","size","heapify","performHeapSort","largest","getSelectionSortProcedures","sortedIndex","j","performSelectionSort","getInsertionSortProcedures","key","performInsertionSort","console","log","Visualiser","useState","visualArray","updateArray","sliderValue","updateSliderValue","isRunning","updateIsRunning","resetArray","num","random","useEffect","className","map","idx","min","max","value","onChange","event","target","disabled","onClick","bubbleSort","selectionSort","insertionSort","mergeSort","heapSort","quickSortWithRightPivot","quickSortWithMidPivot","maxHeight","marginTop","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.f8e31757.chunk.js","sourcesContent":["// Color constants for array bars\nexport const Colors = {\n  BAR_DEFAULT: '#787A7C',  // dark grey\n  BAR_COMPLETED: '#00C5B7', // turqiose\n  COMPARE: '#63F700', // bright green\n  SWAP: '#F79C43', // bright orange\n  PIVOT: 'red' // red\n}\n","export const PROCEDURE_TYPE = {\n  COMPARE: 'compare',\n  SWAP: 'swap',\n  PIVOT: 'pivot', // for quick sort\n}","/**\n * Core engine for the animation. \n * Takes in procedures[] and executes each line of procedure with the corresponding \n * animations & colour\n */\nimport { Colors } from '../styles';\nimport { PROCEDURE_TYPE } from '../utils/procedureTypes';\n\nfunction swapBars(a, b) {\n  const arrayBars = document.getElementsByClassName('array-bar');\n  // swap the bars in the document\n  const temp = arrayBars[a].style.height;\n  arrayBars[a].style.height = arrayBars[b].style.height;\n  arrayBars[b].style.height = temp;\n}\n\nfunction markComplete() {\n  const arrayBars = document.getElementsByClassName('array-bar');\n  for (let i = 0; i < arrayBars.length; i++) {\n    arrayBars[i].style.backgroundColor = Colors.BAR_COMPLETED;\n  }\n}\n\n/** Main exported function */\nexport async function ProceduresReader(procedures, executionSpeed) {\n  const arrayBars = document.getElementsByClassName('array-bar');\n  for (let i = 0; i < procedures.length; i++) {\n    const [a, b] = procedures[i].between;\n\n    // execute the animation for the procedure\n    await ExecuteProcedure(procedures[i], executionSpeed);\n\n    // revert bars back to default color\n    arrayBars[a].style.backgroundColor = Colors.BAR_DEFAULT;\n    arrayBars[b].style.backgroundColor = Colors.BAR_DEFAULT;\n\n    if (i === procedures.length - 1) {\n      markComplete();\n    }\n  }\n}\n\n/**\n * Promise-based with delay so users can see it on screen.\n * Executes the procedure with the corresponding animation based on type. \n */\nasync function ExecuteProcedure(procedure, executionSpeed) {\n  return new Promise((resolve) => {\n    const arrayBars = document.getElementsByClassName('array-bar');\n    const [a, b] = procedure.between;\n    switch (procedure.type) {\n      case PROCEDURE_TYPE.PIVOT:\n        arrayBars[a].style.backgroundColor = Colors.PIVOT;\n        break;\n      case PROCEDURE_TYPE.COMPARE:\n        arrayBars[a].style.backgroundColor = Colors.COMPARE;\n        arrayBars[b].style.backgroundColor = Colors.COMPARE;\n        break;\n      case PROCEDURE_TYPE.SWAP:\n        arrayBars[a].style.backgroundColor = Colors.SWAP;\n        arrayBars[b].style.backgroundColor = Colors.SWAP;\n        swapBars(a, b);\n        break;\n      default:\n        break;\n    }\n    return setTimeout(resolve, executionSpeed);\n  });\n}","import { PROCEDURE_TYPE } from '../utils/procedureTypes';\n\n/**\n * Quicksort Lomuto Partition Scheme\n * This scheme chooses a pivot that is typically the last element in the array. \n */\n\nexport function getQuickSortRightPivotProcedures(array) {\n  if (array.length <= 1) return array;\n  const procedures = [];\n  const auxArray = array.slice();\n  performQuickSortWithRightPivot(procedures, auxArray, 0, auxArray.length - 1);\n\n  return procedures;\n}\n\nfunction performQuickSortWithRightPivot(procedures, auxArray, start, end) {\n  if (start < end) {\n    let pIndex = partitionWithRightPivot(procedures, auxArray, start, end);\n    performQuickSortWithRightPivot(procedures, auxArray, start, pIndex - 1);\n    performQuickSortWithRightPivot(procedures, auxArray, pIndex + 1, end);\n  }\n}\n\nfunction partitionWithRightPivot(procedures, auxArray, start, end) {\n  let pivot = auxArray[end] // use right most element as pivot\n  procedures.push({ type: PROCEDURE_TYPE.PIVOT, between: [end, end] });\n  let pIndex = start;\n  for (let i = start; i < end; i++) {\n    procedures.push({ type: PROCEDURE_TYPE.COMPARE, between: [i, end] });\n    if (auxArray[i] < pivot) {\n      swap(auxArray, i, pIndex)\n      procedures.push({ type: PROCEDURE_TYPE.SWAP, between: [i, pIndex] });\n      pIndex++;\n    }\n  }\n  swap(auxArray, end, pIndex) // swap pivot (arr[end]) with arr[pIndex]\n  procedures.push({ type: PROCEDURE_TYPE.SWAP, between: [end, pIndex] });\n  return pIndex;\n}\n\nfunction swap(arr, firstIndex, secondIndex) {\n  const temp = arr[firstIndex];\n  arr[firstIndex] = arr[secondIndex];\n  arr[secondIndex] = temp;\n}","import { PROCEDURE_TYPE } from '../utils/procedureTypes';\n/**\n * Quicksort Hoare Partition Scheme\n * It uses two indices that start at the ends of the array being partitioned, \n * then move toward each other, until they detect an inversion. \n * The inverted elements are then swapped. When the indices meet, the algorithm stops \n * and returns the final index.\n */\n\n// Reference: https://www.bogotobogo.com/Algorithms/quicksort.php\nexport function getQuickSortMidPivotProcedures(array) {\n  if (array.length <= 1) return array;\n  const procedures = [];\n  const auxArray = array.slice();\n  performQuickSortWithMidPivot(procedures, auxArray, 0, auxArray.length - 1);\n  return procedures;\n}\n\nexport function performQuickSortWithMidPivot(procedures, auxArray, start, end) {\n  if (start >= end) return;\n\n  let mid = Math.floor((start + end) / 2);\n  let pivot = auxArray[mid];\n  let left = start;\n  let right = end;\n\n  procedures.push({ type: PROCEDURE_TYPE.PIVOT, between: [mid, mid] })\n\n  while (left <= right) {\n    while (auxArray[left] < pivot) { left++; }\n\n    while (auxArray[right] > pivot) { right--; }\n\n    procedures.push({ type: PROCEDURE_TYPE.COMPARE, between: [left, right] });\n    if (left <= right) {\n      swap(auxArray, left, right);\n      procedures.push({ type: PROCEDURE_TYPE.SWAP, between: [left, right] });\n      left++; right--;\n    }\n  }\n\n  performQuickSortWithMidPivot(procedures, auxArray, start, right);\n  performQuickSortWithMidPivot(procedures, auxArray, left, end);\n}\n\nfunction swap(arr, firstIndex, secondIndex) {\n  const temp = arr[firstIndex];\n  arr[firstIndex] = arr[secondIndex];\n  arr[secondIndex] = temp;\n}","import { PROCEDURE_TYPE } from '../utils/procedureTypes';\n\nexport function getBubbleSortProcedures(arr) {\n  const procedures = [];\n  if (arr.lengh <= 1) return arr;\n  const auxArray = arr.slice();\n  let runLoop;\n  do {\n    runLoop = false;\n    for (let i = 0; i < auxArray.length - 1; i++) {\n      procedures.push({ type: PROCEDURE_TYPE.COMPARE, between: [i, i + 1] });\n      if (auxArray[i] > auxArray[i + 1]) {\n        swap(auxArray, i, i + 1);\n        procedures.push({ type: PROCEDURE_TYPE.SWAP, between: [i, i + 1] });\n        runLoop = true;\n      }\n    }\n  } while (runLoop);\n  return procedures;\n}\n\nfunction swap(arr, firstIndex, secondIndex) {\n  const temp = arr[firstIndex];\n  arr[firstIndex] = arr[secondIndex];\n  arr[secondIndex] = temp;\n}","/**\n * The Merge Sort implemented here is an in-place Merge Sort. \n * This is two facilitate the animation which requires the target array to be sorted in-place\n * As a result, the performance of this merge sort degrades to O(n^2 log n) since merge is O(n^2) \n * and standard merge sort is O(n log n)\n */\n\n// References: https://github.com/bakeraj4/In-Place-Merge-Sort/blob/master/mergeMain.java\nimport { PROCEDURE_TYPE } from '../utils/procedureTypes';\n\nexport function getMergeSortProcedures(array) {\n  if (array.length <= 1) return array;\n  const procedures = [];\n  let auxArray = array.slice();\n  performMergeSort(procedures, auxArray, 0, auxArray.length - 1);\n  return procedures;\n}\n\nfunction performMergeSort(procedures, auxArray, start, end) {\n  // base case\n  // only one element\n  if (end - start === 0) { }\n  // only two elements, swap them\n  else if (end - start === 1) {\n    procedures.push({ type: PROCEDURE_TYPE.COMPARE, between: [start, end] });\n    if (auxArray[start] > auxArray[end]) {\n      swap(auxArray, start, end);\n      procedures.push({ type: PROCEDURE_TYPE.SWAP, between: [start, end] });\n    }\n  }\n  else {\n    let mid = Math.floor((start + end) / 2);\n    performMergeSort(procedures, auxArray, start, mid);\n    performMergeSort(procedures, auxArray, mid + 1, end);\n    merge(procedures, auxArray, start, end, mid)\n  }\n}\n\nfunction merge(procedures, auxArray, start, end, mid) {\n  let i = start;\n  while (i <= mid) {\n    procedures.push({ type: PROCEDURE_TYPE.COMPARE, between: [i, mid + 1] });\n    if (auxArray[i] > auxArray[mid + 1]) {\n      swap(auxArray, i, mid + 1);\n      procedures.push({ type: PROCEDURE_TYPE.SWAP, between: [i, mid + 1] });\n      push(procedures, auxArray, mid + 1, end);\n    }\n    i++;\n  }\n}\n\nfunction swap(arr, firstIndex, secondIndex) {\n  const temp = arr[firstIndex];\n  arr[firstIndex] = arr[secondIndex];\n  arr[secondIndex] = temp;\n}\n\nfunction push(procedures, arr, start, end) {\n  for (let i = start; i < end; i++) {\n    if (arr[i] > arr[i + 1]) {\n      // procedures.push({ type: PROCEDURE_TYPE.COMPARE, between: [i, i + 1] });\n      swap(arr, i, i + 1);\n      procedures.push({ type: PROCEDURE_TYPE.SWAP, between: [i, i + 1] });\n    }\n  }\n}","\nimport { PROCEDURE_TYPE } from '../utils/procedureTypes';\n// References: https://www.geeksforgeeks.org/heap-sort/\n\nexport function getHeapSortProcedures(array) {\n  if (array.length <= 1) return array;\n  const procedures = [];\n  let auxArray = array.slice();\n  performHeapSort(procedures, auxArray);\n  return procedures;\n}\n\nfunction performHeapSort(procedures, auxArray) {\n\n  let size = auxArray.length;\n\n  // Build max heap (rearrange array) \n  for (let i = Math.floor((size / 2) - 1); i >= 0; i--) {\n    heapify(procedures, auxArray, size, i);\n  }\n\n  // One by one extract an element from heap \n  for (let i = size - 1; i > 0; i--) {\n    // Move current root to end \n    swap(auxArray, 0, i);\n    procedures.push({ type: PROCEDURE_TYPE.SWAP, between: [0, i] });\n    // call max heapify on the reduced heap \n    heapify(procedures, auxArray, i, 0);\n  }\n}\n\n// To heapify a subtree rooted with node i which is \n// an index in arr[]. n is size of heap \nfunction heapify(procedures, auxArray, size, i) {\n  let largest = i;\n  let left = 2 * i + 1;\n  let right = 2 * i + 2;\n\n  // see if child of root exist and whether it's greater than root\n  if (left < size && auxArray[left] > auxArray[largest]) {\n    largest = left;\n  }\n\n  if (right < size && auxArray[right] > auxArray[largest]) {\n    largest = right;\n  }\n\n  if (largest !== i) {\n    swap(auxArray, i, largest);\n    procedures.push({ type: PROCEDURE_TYPE.SWAP, between: [i, largest] });\n    // Recursively heapify the affected sub - tree\n    heapify(procedures, auxArray, size, largest);\n  }\n}\n\nfunction swap(arr, firstIndex, secondIndex) {\n  const temp = arr[firstIndex];\n  arr[firstIndex] = arr[secondIndex];\n  arr[secondIndex] = temp;\n}\n","\nimport { PROCEDURE_TYPE } from '../utils/procedureTypes';\n\nexport function getSelectionSortProcedures(array) {\n  if (array.length <= 1) return array;\n  const procedures = [];\n  let auxArray = array.slice();\n  performSelectionSort(procedures, auxArray);\n  return procedures;\n}\n\nfunction performSelectionSort(procedures, auxArray) {\n  let size = auxArray.length;\n\n  for (let i = 0; i < size - 1; i++) {\n    let sortedIndex = i;\n    for (let j = i + 1; j < size; j++) {\n      procedures.push({ type: PROCEDURE_TYPE.COMPARE, between: [j, sortedIndex] });\n      if (auxArray[j] < auxArray[sortedIndex]) {\n        sortedIndex = j;\n      }\n    }\n    swap(auxArray, i, sortedIndex);\n    procedures.push({ type: PROCEDURE_TYPE.SWAP, between: [i, sortedIndex] });\n  }\n}\n\n\nfunction swap(arr, firstIndex, secondIndex) {\n  const temp = arr[firstIndex];\n  arr[firstIndex] = arr[secondIndex];\n  arr[secondIndex] = temp;\n}\n","\nimport { PROCEDURE_TYPE } from '../utils/procedureTypes';\n\nexport function getInsertionSortProcedures(array) {\n  if (array.length <= 1) return array;\n  const procedures = [];\n  let auxArray = array.slice();\n  performInsertionSort(procedures, auxArray);\n  console.log(procedures);\n  return procedures;\n}\n\nfunction performInsertionSort(procedures, auxArray) {\n  let size = auxArray.length;\n  for (let i = 1; i < size; ++i) {\n    let key = auxArray[i];\n    let j = i - 1;\n\n    procedures.push({ type: PROCEDURE_TYPE.COMPARE, between: [j, i] });\n    while (j >= 0 && auxArray[j] > key) {\n      auxArray[j + 1] = auxArray[j];\n      procedures.push({ type: PROCEDURE_TYPE.SWAP, between: [j+1, j] });\n      j--;\n    }\n    auxArray[j + 1] = key;\n  }\n\n}","import React, { useState, useEffect } from 'react';\n\nimport { ProceduresReader } from './VisualiserCore';\nimport { generateRandomNumber } from '../utils/generators';\nimport { getQuickSortRightPivotProcedures } from '../algorithms/QuickSortRightPivot';\nimport { getQuickSortMidPivotProcedures } from '../algorithms/QuickSortMidPivot';\nimport { getBubbleSortProcedures } from '../algorithms/BubbleSort';\nimport { getMergeSortProcedures } from '../algorithms/MergeSort';\nimport { getHeapSortProcedures } from '../algorithms/HeapSort';\nimport { getSelectionSortProcedures } from '../algorithms/SelectionSort';\nimport { getInsertionSortProcedures } from '../algorithms/InsertionSort';\n\nimport './Visualiser.css';\nimport { Colors } from '../styles';\n\nconst ANIMATION_SPEED = 0.1;\nconst MIN_NUM_ARRAYS = 50;\nconst MAX_NUM_ARRAYS = 800;\n\nconst Visualiser = () => {\n  const [visualArray, updateArray] = useState(() => []);\n  const [sliderValue, updateSliderValue] = useState(\n    (MAX_NUM_ARRAYS + MIN_NUM_ARRAYS) / 2\n  );\n  const [isRunning, updateIsRunning] = useState(false);\n\n  function resetArray() {\n    const array = [];\n    for (let i = 0; i < sliderValue; i++) {\n      const num = generateRandomNumber(3, 500);\n      array.push(num);\n      updateArray(array);\n    }\n    // set the colors to default color\n    const arrayBars = document.getElementsByClassName('array-bar');\n    for (let j = 0; j < arrayBars.length; j++) {\n      arrayBars[j].style.backgroundColor = Colors.BAR_DEFAULT;\n    }\n  }\n\n  // when the component first mounts, create a new random array\n  useEffect(() => resetArray(), []);\n\n\n  /** SORTING FUNCTIONS */\n  async function quickSortWithRightPivot() {\n    const procedures = getQuickSortRightPivotProcedures(visualArray);\n    await ProceduresReader(procedures, ANIMATION_SPEED);\n    updateIsRunning(false);\n  }\n\n  async function quickSortWithMidPivot() {\n    const procedures = getQuickSortMidPivotProcedures(visualArray);\n    await ProceduresReader(procedures, ANIMATION_SPEED);\n    updateIsRunning(false);\n  }\n\n  async function mergeSort() {\n    const procedures = getMergeSortProcedures(visualArray);\n    await ProceduresReader(procedures, ANIMATION_SPEED);\n    updateIsRunning(false);\n  }\n\n  async function bubbleSort() {\n    const procedures = getBubbleSortProcedures(visualArray);\n    await ProceduresReader(procedures, ANIMATION_SPEED);\n    updateIsRunning(false);\n  }\n\n  async function heapSort() {\n    const procedures = getHeapSortProcedures(visualArray);\n    await ProceduresReader(procedures, ANIMATION_SPEED);\n    updateIsRunning(false);\n  }\n\n  async function selectionSort() {\n    const procedures = getSelectionSortProcedures(visualArray);\n    await ProceduresReader(procedures, ANIMATION_SPEED);\n    updateIsRunning(false);\n  }\n  async function insertionSort() {\n    const procedures = getInsertionSortProcedures(visualArray);\n    await ProceduresReader(procedures, ANIMATION_SPEED);\n    updateIsRunning(false);\n  }\n\n  return (\n    <div className=\"visualiser-layout\">\n      <h1>Sorting Visualiser</h1>\n      <p>By Renyi Tan</p>\n      <div className=\"visualiser-container\">\n        {visualArray.map((i, idx) => (\n          <div\n            className=\"array-bar\"\n            key={idx}\n            style={{ height: i, backgroundColor: Colors.BAR_DEFAULT }}\n          />\n        ))}\n      </div>\n      <div className=\"controls-container\">\n        <div className=\"slider-group\">\n          <div className=\"slider\">\n            <input\n              type=\"range\"\n              min={MIN_NUM_ARRAYS}\n              max={MAX_NUM_ARRAYS}\n              value={sliderValue}\n              onChange={(event) => {\n                updateSliderValue(event.target.value);\n                resetArray();\n              }}\n              disabled={isRunning}\n            />\n            <span>{sliderValue}</span>\n          </div>\n        </div>\n        <div className=\"button-group\">\n          <button\n            className=\"btn\"\n            onClick={() => {\n              bubbleSort();\n              updateIsRunning(true);\n            }}\n            disabled={isRunning}\n          >\n            Bubble Sort\n          </button>\n          <button\n            className=\"btn\"\n            onClick={() => {\n              selectionSort();\n              updateIsRunning(true);\n            }}\n            disabled={isRunning}\n          >\n            Selection Sort\n          </button>\n          <button\n            className=\"btn\"\n            onClick={() => {\n              insertionSort();\n              updateIsRunning(true);\n            }}\n            disabled={isRunning}\n          >\n            Insertion Sort\n          </button>\n          <button\n            className=\"btn\"\n            onClick={() => {\n              mergeSort();\n              updateIsRunning(true);\n            }}\n            disabled={isRunning}\n          >\n            Merge Sort\n          </button>\n          <button\n            className=\"btn\"\n            onClick={() => {\n              heapSort();\n              updateIsRunning(true);\n            }}\n            disabled={isRunning}\n          >\n            Heap Sort\n          </button>\n          <button\n            className=\"btn\"\n            onClick={() => {\n              quickSortWithRightPivot();\n              updateIsRunning(true);\n            }}\n            disabled={isRunning}\n          >\n            Quick Sort (Lomuto)\n          </button>\n          <button\n            className=\"btn\"\n            onClick={() => {\n              quickSortWithMidPivot();\n              updateIsRunning(true);\n            }}\n            disabled={isRunning}\n          >\n            Quick Sort (Hoare)\n          </button>\n        </div>\n        <div className=\"reset-container\">\n          <button\n            className=\"btn\"\n            style={{ maxHeight: 20, marginTop: 5 }}\n            onClick={() => {\n              resetArray();\n            }}\n            disabled={isRunning}\n          >\n            Reset Arrays\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Visualiser;\n","export function generateRandomNumber(start, end) {\n  return Math.floor(Math.random() * end) + start;\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Visualiser from './app/Visualiser';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Visualiser />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}